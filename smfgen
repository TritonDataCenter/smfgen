#!/usr/bin/env node

/*
 * smfgen: generates an SMF manifest from a JSON description of the service. See
 *     emitManifest below for details.
 *
 * This tool is still experimental. It's only intended to generate simple
 * manifests. For more details, see smf(5).
 */

var util = require('util');

var assert = require('assert-plus');

var PROGNAME = require('./package').name;

var HEADER_COMMENT = [
    '',
    util.format('    Manifest automatically generated by %s.', PROGNAME),
    ''
].join('\n');

function checkAndApplyContext(prefix, conf, applyto)
{
	var s = (prefix ? prefix + '.' : '');

	if (conf.hasOwnProperty('user')) {
		assert.string(conf.user, s + 'user');
		applyto.user = conf.user;
	}

	if (conf.hasOwnProperty('group')) {
		assert.string(conf.group, s + 'group');
		applyto.group = conf.group;
	}

	if (conf.hasOwnProperty('environment')) {
		assert.object(conf.environment, s + 'environment');
		applyto.environment = conf.environment;
	}

	if (conf.hasOwnProperty('privileges')) {
		assert.arrayOfString(conf.privileges, s + 'privileges');
		applyto.privileges = conf.privileges;
	}

	if (conf.hasOwnProperty('working_directory')) {
		assert.string(conf.working_directory, s + 'working_directory');
		applyto.working_directory = conf.working_directory;
	}

	if (conf.hasOwnProperty('exec')) {
		assert.string(conf.exec, s + 'exec');
		applyto.exec = conf.exec;
	}

	if (conf.hasOwnProperty('timeout')) {
		assert.number(conf.timeout, s + 'timeout');
		applyto.timeout = conf.timeout;
	}

	if (conf.hasOwnProperty('enabled')) {
		assert.bool(conf.enabled, s + 'enabled');
		applyto.enabled = conf.enabled;
	}
}

function shouldEmitMethodContext(conf)
{
	var lookfor = ['user', 'group', 'privileges', 'environment',
	    'working_directory'];
	for (var i = 0; i < lookfor.length; i++) {
		if (conf.hasOwnProperty(lookfor[i]))
			return (true);
	}
	return (false);
}

function emitMethodContext(xml, conf)
{
	var attrs = {};
	if (conf.working_directory)
		attrs.working_directory = conf.working_directory;
	xml.emitStart('method_context', attrs);

	attrs = {};
	if (conf.user)
		attrs.user = conf.user;
	if (conf.group)
		attrs.group = conf.group;
	if (conf.privileges)
		attrs.privileges = conf.privileges.join(',');
	if (Object.keys(attrs).length > 0)
		xml.emitEmpty('method_credential', attrs);

	if (conf.environment) {
		xml.emitStart('method_environment');
		Object.keys(conf.environment).forEach(function (k) {
			var v = conf.environment[k];
			xml.emitEmpty('envvar', { name: k, value: v });
		});
		xml.emitEnd('method_environment');
	}

	xml.emitEnd('method_context');
}

function emitMethod(xml, conf)
{
	var attrs = {
		type: 'method',
		name: conf.name,
		exec: conf.exec,
		timeout_seconds: conf.timeout
	};
	if (shouldEmitMethodContext(conf)) {
		xml.emitStart('exec_method', attrs);
		emitMethodContext(xml, conf);
		xml.emitEnd('exec_method');
	} else {
		xml.emitEmpty('exec_method', attrs);
	}
}

/*
 * Emit an SMF manifest for the service described by the given JSON.  The
 * expected structure of the JSON stream is specified in README.md.
 *
 * Note that for backwards compatibility we also accept a string in place of
 * the method object for 'start', 'stop', and 'refresh', which is assumed to be
 * the 'exec' value for that method.
 */
function emitManifest(stream, conf)
{
	var xml = new XmlEmitter(stream);
	var deps = [ 'svc:/milestone/multi-user:default' ];
	var fmri, i;

	/* default values for start/stop methods */
	var start = { name: 'start', timeout: 10 };
	var stop = { name: 'stop', timeout: 30, exec: ':kill' };
	var refresh = { name: 'refresh', timeout: 10, exec: ':true' };

	assert.string(conf.ident, 'ident');
	assert.string(conf.label, 'label');

	/*
	 * Apply the global versions of method context and exec from the root
	 * of the config object first, then override them if more specific
	 * options exist for a particular method.
	 */
	checkAndApplyContext(null, conf, start);
	checkAndApplyContext(null, conf, stop);
	checkAndApplyContext(null, conf, refresh);

	if (conf.hasOwnProperty('start')) {
		if (typeof (conf.start) === 'string') {
			start.exec = conf.start;
		} else {
			checkAndApplyContext('start', conf.start, start);
		}
	}
	assert.string(start.exec, 'start.exec');
	start.exec += ' &';

	if (conf.hasOwnProperty('stop')) {
		if (typeof (conf.stop) === 'string')
			stop.exec = conf.stop;
		else
			checkAndApplyContext('stop', conf.stop, stop);
	}

	if (conf.hasOwnProperty('refresh')) {
		if (typeof (conf.refresh) === 'string')
			refresh.exec = conf.refresh;
		else
			checkAndApplyContext('refresh', conf.refresh, refresh);
	}

	if (conf.hasOwnProperty('dependencies')) {
		assert.arrayOfString(conf.dependencies, 'dependencies');
		conf.dependencies.forEach(function (dep) {
			deps.push(dep);
		});
	}

	assert.optionalString(conf.category, 'category');
	fmri = util.format('%s/%s',
	    (conf.category || 'application'), conf.ident);

	xml.emitDoctype('service_bundle', 'SYSTEM',
	    '/usr/share/lib/xml/dtd/service_bundle.dtd.1');
	xml.emitComment(HEADER_COMMENT);

	xml.emitStart('service_bundle', {
		'type': 'manifest',
		/* JSSTYLED */
		'name': fmri.replace(/\//g, '-')
	});

	xml.emitStart('service', {
		'name': fmri,
		'type': 'service',
		'version': '1'
	});

	var enabled = conf.hasOwnProperty('enabled') ? conf.enabled : true;
	xml.emitEmpty('create_default_instance', { 'enabled': enabled });

	i = 0;
	deps.forEach(function (dep) {
		xml.emitStart('dependency', {
			'name': 'dep' + i++,
			'grouping': 'require_all',
			'restart_on': 'error',
			'type': 'service'
		});

		xml.emitEmpty('service_fmri', { 'value': dep });
		xml.emitEnd('dependency');
	});

	emitMethod(xml, start);
	emitMethod(xml, stop);
	if (conf.hasOwnProperty('refresh'))
		emitMethod(xml, refresh);

	xml.emitStart('template');
	xml.emitStart('common_name');
	xml.emitStart('loctext', {
		'xml:lang': 'C'
	}, { 'bare': true });
	xml.emitCData(conf['label']);
	xml.emitEnd('loctext', { 'bare': true });
	xml.emitEnd('common_name');
	xml.emitEnd('template');

	xml.emitEnd('service');
	xml.emitEnd('service_bundle');
}

/*
 * Basic interface for emitting well-formed XML. This isn't bulletproof, but it
 * does escape values (not tags or keys) and checks for basic errors.
 */
function XmlEmitter(stream)
{
	this.xe_stream = stream;
	this.xe_stack = [];
}

XmlEmitter.prototype.emitDoctype = function (name, type, path)
{
	this.xe_stream.write('<?xml version="1.0"?>\n');
	this.xe_stream.write('<!DOCTYPE ' + name + ' ' + type + ' "' +
	    path + '">\n');
};

XmlEmitter.prototype.escape = function (str)
{
	/* BEGIN JSSTYLED */
	return (str.toString().replace(/&/g, '&amp;').
	    replace(/</g, '&lt;').
	    replace(/>/g, '&gt;').
	    replace(/"/g, '&quot;'));
	/* END JSSTYLED */
};

XmlEmitter.prototype.emitIndent = function ()
{
	var str = '';
	var i;

	for (i = 0; i < this.xe_stack.length; i++)
		str += '    ';

	this.xe_stream.write(str);
};

XmlEmitter.prototype.emitEmpty = function (name, attrs)
{
	this.emitIndent();
	this.xe_stream.write('<' + name + ' ');
	this.emitAttrs(attrs);
	this.xe_stream.write('/>\n');
};

XmlEmitter.prototype.emitAttrs = function (attrs)
{
	var key;

	if (!attrs)
		return;

	for (key in attrs)
		this.xe_stream.write(key + '=\"' +
		    this.escape(attrs[key]) + '\" ');
};

XmlEmitter.prototype.emitStart = function (name, attrs, opts)
{
	this.emitIndent();
	this.xe_stack.push(name);

	this.xe_stream.write('<' + name + ' ');
	this.emitAttrs(attrs);
	this.xe_stream.write('>');

	if (!opts || !opts['bare'])
		this.xe_stream.write('\n');
};

XmlEmitter.prototype.emitEnd = function (name, opts)
{
	var check = this.xe_stack.pop();

	assert.equal(name, check);

	if (!opts || !opts['bare'])
		this.emitIndent();

	this.xe_stream.write('</' + name + '>\n');
};

XmlEmitter.prototype.emitCData = function (data)
{
	this.xe_stream.write(this.escape(data));
};

XmlEmitter.prototype.emitComment = function (content)
{
	this.xe_stream.write('<!-- ' + content + ' -->\n');
};

function usage()
{
	var msg = [
		util.format('Usage: %s [options]', PROGNAME),
		'',
		'Generate an SMF manifest from a JSON or CLI description of the service',
		'',
		'Examples',
		'  Create a service from a JSON file:',
		'    $ cat service.json | smfgen',
		'',
		'  Create a service from CLI arguments:',
		'    $ smfgen -i my-service -l "My Service" -s /opt/custom/bin/my-service',
		'',
		'Options',
		'  -c, --category <name>  service category, defaults to "application"',
		'  -d, --cwd <dir>        the directory to use when executing methods',
		'  -D, --dependency <dep> service dependency, multiple arguments allowed',
		'  -e, --env <key=val>    a single env var to use in the form of KEY=value, multiple arguments allowed',
		'  -g, --group <group>    group to use when executing methods',
		'  -h, --help             print this usage message and exit',
		'  -i, --ident <ident>    SMF identifier basename',
		'  -l, --label <label>    human-readable name of the service',
		'  -p, --privilege <priv> RBAC privilege names, multiple arguments allowed',
		'  -r, --refresh <exec>   refresh script path, defaults to :true (noop)',
		'  -s, --start <exec>     start script path',
		'  -S, --stop <exec>      stop script path, defaults to :kill',
		'  -t, --timeout <num>    method timeout in seconds',
		'  -u, --user <user>      user to use when executing methods'
	].join('\n');

	return msg;
}

function main()
{
	var data;

	if (process.argv.length <= 2) {
		// no arguments, just read stdin
		data = '';
		process.stdin.setEncoding('utf8');
		process.stdin.on('data', function (chunk) { data += chunk; });
		process.stdin.on('end', function () {
			var json;

			try {
				json = JSON.parse(data);
				emitManifest(process.stdout, json);
			} catch (ex) {
				console.error('%s: %s', PROGNAME, ex.message);
				process.exit(1);
			}
		});

		return;
	}

	var getopt = require('posix-getopt');

	var options = [
		'c:(category)',
		'd:(cwd)',
		'D:(dependency)',
		'e:(env)',
		'g:(group)',
		'h(help)',
		'i:(ident)',
		'l:(label)',
		'p:(privilege)',
		'r:(refresh)',
		's:(start)',
		'S:(stop)',
		't:(timeout)',
		'u:(user)'
	].join('');
	var parser = new getopt.BasicParser(options, process.argv);

	data = {
		dependencies: [],
		privileges: [],
		environment: {},
		refresh: {},
		start: {},
		stop: {}
	};
	var option;
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
		case 'c': data.category = option.optarg; break;
		case 'D': data.dependencies.push(option.optarg); break;
		case 'd': data.working_directory = option.optarg; break;
		case 'e':
			var arg = option.optarg;
			var eq = arg.indexOf('=');
			if (eq < 0) {
				console.error('env must be in form key=value');
				process.exit(1);
				break;
			}
			data.environment[arg.substr(0, eq)] = arg.substr(eq + 1);
			break;
		case 'g': data.group = option.optarg; break;
		case 'h': console.log(usage()); process.exit(0); break;
		case 'i': data.ident = option.optarg; break;
		case 'l': data.label = option.optarg; break;
		case 'p': data.privileges.push(option.optarg); break;
		case 'r': data.refresh.exec = option.optarg; break;
		case 's': data.start.exec = option.optarg; break;
		case 'S': data.stop.exec = option.optarg; break;
		case 'u': data.user = option.optarg; break;
		case 't':
			data.timeout = parseInt(option.optarg, 10);
			assert.number(data.timeout, 'timeout must be a number');
			assert(data.timeout >= 0, 'timeout must be positive');
			break;
		default: console.error(usage()); process.exit(1); break;
		}
	}

	// Remove empty elements
	Object.keys(data).forEach(function (prop) {
		var o = data[prop];

		if ((typeof (o) === 'object' && Object.keys(o).length === 0) ||
		    (Array.isArray(o) && o.length === 0)) {
			delete data[prop];
		}
	});

	try {
		emitManifest(process.stdout, data);
	} catch (ex) {
		console.error('%s: %s', PROGNAME, ex.message);
		process.exit(1);
	}
}

if (require.main === module)
	main();
else
	module.exports = emitManifest;
