#!/usr/bin/env node

/*
 * smfgen: generates an SMF manifest from a JSON description of the service. See
 *     emitManifest below for details.
 *
 * This tool is still experimental. It's only intended to generate simple
 * manifests. For more details, see smf(5).
 */

var mod_assert = require('assert');

var header_comment = [
    '',
    '    Manifest automatically generated by smfgen.',
    ''
].join('\n');

/*
 * Emit an SMF manifest for the service described by the given JSON:
 *
 * ident		The SMF identifier for the service.  The full SMF
 * 			identifier (FMRI) will be constructed from the category
 * 			and identifier.
 *
 * [category]		Service category (default: "application").
 *
 * label		The human-readable name of the service.
 *
 * [dependencies]	Array of service FMRIs that must be online before
 * 			this service is started.
 *
 * start		Script that starts the actual service. This invocation
 * 			may run the service synchronously or in the background.
 *			Note that this mechanism does not allow you to use
 *			SMF's built in timeout for service startup, since it
 *			doesn't know when the service has actually started.
 *
 * [stop]		Script that stops this service.
 */
function emitManifest(stream, conf)
{
	var xml = new XmlEmitter(stream);
	var stop = {};
	var deps = [ 'svc:/milestone/multi-user:default' ];
	var fmri, i;

	mod_assert.ok(conf.hasOwnProperty('ident') &&
	    typeof (conf['ident']) == 'string',
	    '"ident" property must be a string');
	mod_assert.ok(conf.hasOwnProperty('label') &&
	    typeof (conf['label']) == 'string',
	    '"label" property must be a string');
	mod_assert.ok(conf.hasOwnProperty('start') &&
	    typeof (conf['start']) == 'string',
	    '"start" property must be a string');

	if (conf.hasOwnProperty('dependencies')) {
		mod_assert.ok(Array.isArray(conf['dependencies']),
		    '"dependencies" property must be an array');
		conf['dependencies'].forEach(function (dep) {
			mod_assert.equal(typeof (dep), 'string');
			deps.push(dep);
		});
	}

	if (conf.hasOwnProperty(conf['stop'])) {
		mod_assert.equal(typeof (conf['stop']), 'string',
		    '"stop" property must be a string');
		stop = conf['stop'];
	} else {
		stop = ':kill';
	}

	if (conf.hasOwnProperty('category')) {
		mod_assert.equal(typeof (conf['category']), 'string',
		    '"category" must be a string');
		fmri = conf['category'] + '/' + conf['ident'];
	} else {
		fmri = 'application/' + conf['ident'];
	}

	xml.emitDoctype('service_bundle', 'SYSTEM',
	    '/usr/share/lib/xml/dtd/service_bundle.dtd.1');
	xml.emitComment(header_comment);

	xml.emitStart('service_bundle', {
		'type': 'manifest',
		/* JSSTYLED */
		'name': fmri.replace(/\//g, '-')
	});

	xml.emitStart('service', {
		'name': fmri,
		'type': 'service',
		'version': '1'
	});

	xml.emitEmpty('create_default_instance', { 'enabled': 'true' });

	deps.forEach(function (dep) {
		xml.emitStart('dependency', {
			'name': 'dep' + i++,
			'grouping': 'require_all',
			'restart_on': 'error',
			'type': 'service'
		});

		xml.emitEmpty('service_fmri', { 'value': dep });
		xml.emitEnd('dependency');
	});

	xml.emitEmpty('exec_method', {
		'type': 'method',
		'name': 'start',
		'exec': conf['start'] + ' &',
		'timeout_seconds': 10
	});

	xml.emitEmpty('exec_method', {
		'type': 'method',
		'name': 'stop',
		'exec': stop,
		'timeout_seconds': 30
	});

	xml.emitStart('template');
	xml.emitStart('common_name');
	xml.emitStart('loctext', {
		'xml:lang': 'C'
	}, { 'bare': true });
	xml.emitCData(conf['label']);
	xml.emitEnd('loctext', { 'bare': true });
	xml.emitEnd('common_name');
	xml.emitEnd('template');

	xml.emitEnd('service');
	xml.emitEnd('service_bundle');
}

/*
 * Basic interface for emitting well-formed XML. This isn't bulletproof, but it
 * does escape values (not tags or keys) and checks for basic errors.
 */
function XmlEmitter(stream)
{
	this.xe_stream = stream;
	this.xe_stack = [];
}

XmlEmitter.prototype.emitDoctype = function (name, type, path)
{
	this.xe_stream.write('<?xml version="1.0"?>\n');
	this.xe_stream.write('<!DOCTYPE ' + name + ' ' + type + ' "' +
	    path + '">\n');
};

XmlEmitter.prototype.escape = function (str)
{
	/* BEGIN JSSTYLED */
	return (str.toString().replace(/&/g, '&amp;').
	    replace(/</g, '&lt;').
	    replace(/>/g, '&gt;').
	    replace(/"/g, '&quot;'));
	/* END JSSTYLED */
};

XmlEmitter.prototype.emitIndent = function ()
{
	var str = '';
	var i;

	for (i = 0; i < this.xe_stack.length; i++)
		str += '    ';

	this.xe_stream.write(str);
};

XmlEmitter.prototype.emitEmpty = function (name, attrs)
{
	this.emitIndent();
	this.xe_stream.write('<' + name + ' ');
	this.emitAttrs(attrs);
	this.xe_stream.write('/>\n');
};

XmlEmitter.prototype.emitAttrs = function (attrs)
{
	var key;

	if (!attrs)
		return;

	for (key in attrs)
		this.xe_stream.write(key + '=\"' +
		    this.escape(attrs[key]) + '\" ');
};

XmlEmitter.prototype.emitStart = function (name, attrs, opts)
{
	this.emitIndent();
	this.xe_stack.push(name);

	this.xe_stream.write('<' + name + ' ');
	this.emitAttrs(attrs);
	this.xe_stream.write('>');

	if (!opts || !opts['bare'])
		this.xe_stream.write('\n');
};

XmlEmitter.prototype.emitEnd = function (name, opts)
{
	var check = this.xe_stack.pop();

	mod_assert.equal(name, check);

	if (!opts || !opts['bare'])
		this.emitIndent();

	this.xe_stream.write('</' + name + '>\n');
};

XmlEmitter.prototype.emitCData = function (data)
{
	this.xe_stream.write(this.escape(data));
};

XmlEmitter.prototype.emitComment = function (content)
{
	this.xe_stream.write('<!-- ' + content + ' -->\n');
};

function main()
{
	var stdin, data, json;

	data = '';
	stdin = process.openStdin();
	stdin.setEncoding('utf8');
	stdin.on('data', function (chunk) { data += chunk; });
	stdin.on('end', function () {
		try {
			json = JSON.parse(data);
			emitManifest(process.stdout, json);
		} catch (ex) {
			console.error('smfgen: ' + ex.message);
			process.exit(1);
		}
	});
}

main();
